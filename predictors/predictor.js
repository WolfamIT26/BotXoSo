/**
 * N√ÇNG C·∫§P 5.5: Ph√¢n t√≠ch xu h∆∞·ªõng d√†i (5-7 k·ª≥)
 */

const fs = require('fs');
const path = require('path');

/**
 * N√ÇNG C·∫§P 5.5: Ph√¢n t√≠ch c√¢n b·∫±ng thay v√¨ si√™u ph·∫£n ·ª©ng
 * ƒê√£ c·∫≠p nh·∫≠t ƒë·ªÉ kh√¥ng c√≤n ph·ª• thu·ªôc v√†o limitList t·ª´ tham s·ªë options
 */
function balancedAnalysis(history, index) { // X√≥a tham s·ªë limitList
    // ƒê·∫£m b·∫£o d·ªØ li·ªáu h·ª£p l·ªá
    if (!history || !Array.isArray(history) || history.length < 3) {
        return {
            prediction: Math.random() >= 0.5,
            strategy: "Random",
            reason: "Kh√¥ng ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ ph√¢n t√≠ch"
        };
    }
    
    // ƒê·∫£m b·∫£o numbers l√† s·ªë, kh√¥ng ph·∫£i string
    const checkedHistory = history.map(item => {
        if (item.numbers && Array.isArray(item.numbers)) {
            return {
                ...item,
                numbers: item.numbers.map(num => typeof num === 'string' ? parseInt(num, 10) : num)
            };
        }
        return item;
    });

    // Ki·ªÉm tra d·ªØ li·ªáu sau khi chuy·ªÉn ƒë·ªïi

    const allHistory = checkedHistory.map(item => item.numbers[index] >= 5 ? 'T' : 'X');

    // S·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh thay v√¨ limitList
    const shortLimit = Math.min(5, allHistory.length);
    const mediumLimit = Math.min(12, allHistory.length);
    const longLimit = Math.min(20, allHistory.length);

    // T√≠nh t·ª∑ l·ªá t·ª´ nhi·ªÅu kho·∫£ng th·ªùi gian
    const shortTaiCount = allHistory.slice(0, shortLimit).filter(r => r === 'T').length;
    const shortTaiRate = shortTaiCount / shortLimit;

    const mediumTaiCount = allHistory.slice(0, mediumLimit).filter(r => r === 'T').length;
    const mediumTaiRate = mediumTaiCount / mediumLimit;
    
    // C·∫¢I TI·∫æN: Th√™m ph√¢n t√≠ch d√†i h·∫°n
    const longTaiCount = allHistory.slice(0, longLimit).filter(r => r === 'T').length;
    const longTaiRate = longTaiCount / longLimit;

    // Gi·ªØ ph·∫ßn c√≤n l·∫°i c·ªßa h√†m kh√¥ng ƒë·ªïi
    // C·∫¢I TI·∫æN: ƒêi·ªÅu ch·ªânh ng∆∞·ª°ng nh·∫≠n di·ªán xu h∆∞·ªõng m·∫°nh
    if (shortTaiRate >= 0.7) { // Gi·∫£m t·ª´ 0.75 xu·ªëng 0.7
        return {
            prediction: true,
            strategy: "FollowStrongTaiTrend",
            reason: `Theo xu h∆∞·ªõng T√†i m·∫°nh (${Math.round(shortTaiRate * 100)}%)`
        };
    }
    else if (shortTaiRate <= 0.3) { // TƒÉng t·ª´ 0.25 l√™n 0.3
        return {
            prediction: false,
            strategy: "FollowStrongXiuTrend",
            reason: `Theo xu h∆∞·ªõng X·ªâu m·∫°nh (${Math.round((1 - shortTaiRate) * 100)}%)`
        };
    }

    // C·∫¢I TI·∫æN: ƒêi·ªÅu ch·ªânh ng∆∞·ª°ng ph√°t hi·ªán ƒë·ª©t g√£y
    if (Math.abs(shortTaiRate - mediumTaiRate) >= 0.4) { // Gi·∫£m t·ª´ 0.45 xu·ªëng 0.4
        console.log(`Ph√°t hi·ªán ƒë·ª©t g√£y m·∫°nh: Ng·∫Øn ${Math.round(shortTaiRate * 100)}% vs Trung ${Math.round(mediumTaiRate * 100)}%`);

        return {
            prediction: shortTaiRate >= 0.5,
            strategy: "StrongTrendBreak",
            reason: `Ph√°t hi·ªán ƒë·ª©t g√£y m·∫°nh, theo xu h∆∞·ªõng ng·∫Øn h·∫°n ${shortTaiRate >= 0.5 ? 'T√†i' : 'X·ªâu'}`
        };
    }

    // C·∫¢I TI·∫æN: Th√™m so s√°nh xu h∆∞·ªõng d√†i h·∫°n
    if (Math.abs(shortTaiRate - longTaiRate) >= 0.35) { // Gi·∫£m t·ª´ 0.4 xu·ªëng 0.35
        console.log(`Ph√°t hi·ªán thay ƒë·ªïi xu h∆∞·ªõng d√†i: Ng·∫Øn ${Math.round(shortTaiRate * 100)}% vs D√†i ${Math.round(longTaiRate * 100)}%`);
        
        return {
            prediction: shortTaiRate >= 0.5,
            strategy: "LongTermShift", 
            reason: `Ph√°t hi·ªán thay ƒë·ªïi xu h∆∞·ªõng, ∆∞u ti√™n xu h∆∞·ªõng g·∫ßn ƒë√¢y ${shortTaiRate >= 0.5 ? 'T√†i' : 'X·ªâu'}`
        };
    }

    // C·∫¢I TI·∫æN 6: ƒêi·ªÅu ch·ªânh ng∆∞·ª°ng nh·∫≠n di·ªán xu h∆∞·ªõng RecentXiuEmphasis v√¨ c√≥ hi·ªáu su·∫•t t·ªët h∆°n
    if (allHistory.length >= 3) {
        const lastThree = allHistory.slice(0, 3);
        const taiCount = lastThree.filter(r => r === 'T').length;
        
        if (taiCount >= 2) {
            // Gi·∫£m ∆∞u ti√™n T√†i do hi·ªáu su·∫•t th·∫•p h∆°n
            if (Math.random() < 0.65) { // 65% kh·∫£ nƒÉng theo xu h∆∞·ªõng T√†i
                return {
                    prediction: true,
                    strategy: "RecentTaiEmphasis",
                    reason: `∆Øu ti√™n k·∫øt qu·∫£ g·∫ßn nh·∫•t: T√†i chi·∫øm ∆∞u th·∫ø (${taiCount}/3)`
                };
            } else {
                return {
                    prediction: false,
                    strategy: "EmergencyReversal",
                    reason: "ƒê·∫£o chi·ªÅu chi·∫øn thu·∫≠t m·∫∑c d√π T√†i chi·∫øm ∆∞u th·∫ø"
                };
            }
        } else if (taiCount <= 1) {
            // TƒÉng ∆∞u ti√™n X·ªâu do hi·ªáu su·∫•t t·ªët h∆°n
            return {
                prediction: false,
                strategy: "RecentXiuEmphasis",
                reason: `∆Øu ti√™n k·∫øt qu·∫£ g·∫ßn nh·∫•t: X·ªâu chi·∫øm ∆∞u th·∫ø (${3-taiCount}/3)`
            };
        }
    }

    // C·∫¢I TI·∫æN: Th√™m chi·∫øn l∆∞·ª£c ph·∫£n h·ªìi nhanh ƒë·ªëi v·ªõi ƒë·∫£o chi·ªÅu
    if (allHistory.length >= 5) {
        const reversalPattern = (allHistory[0] !== allHistory[1] && 
                               allHistory[1] !== allHistory[2] && 
                               allHistory[2] !== allHistory[3]);
        
        if (reversalPattern) {
            return {
                prediction: allHistory[0] === 'T',  // Theo k·ª≥ g·∫ßn nh·∫•t
                strategy: "RapidResponseReversal",
                reason: "Ph√°t hi·ªán m·∫´u ƒë·∫£o chi·ªÅu li√™n t·ª•c, theo h∆∞·ªõng k·ª≥ g·∫ßn nh·∫•t"
            };
        }
    }

    // C·∫¢I TI·∫æN: Tri·ªát ti√™u nhi·ªÖu ng·∫´u nhi√™n
    if (Math.abs(shortTaiRate - 0.5) < 0.1 && Math.abs(mediumTaiRate - 0.5) < 0.1) {
        // N·∫øu t·ª∑ l·ªá r·∫•t c√¢n b·∫±ng, tƒÉng y·∫øu t·ªë ng·∫´u nhi√™n
        return {
            prediction: Math.random() >= 0.5, 
            strategy: "PureRandom",
            reason: "Ph√¢n b·ªë c·ª±c k·ª≥ c√¢n b·∫±ng, s·ª≠ d·ª•ng d·ª± ƒëo√°n ng·∫´u nhi√™n ho√†n to√†n"
        };
    }

    // TƒÉng tr·ªçng s·ªë cho ReverseStreak trong balancedAnalysis
    // Th√™m ƒëi·ªÅu ki·ªán nh·∫≠n di·ªán chu·ªói ƒë·∫£o chi·ªÅu
    if (allHistory.length >= 4) {
        const lastThree = allHistory.slice(0, 3);
        const allSame = lastThree.every(result => result === lastThree[0]);
        if (allSame) {
            return {
                prediction: lastThree[0] !== 'T',
                strategy: "ReverseStreak",
                reason: `Ph√°t hi·ªán chu·ªói ${lastThree[0] === 'T' ? 'T√†i' : 'X·ªâu'} li√™n ti·∫øp, ƒë·∫£o chi·ªÅu d·ª± ƒëo√°n`
            };
        }
    }

    // Gi·ªØ ph∆∞∆°ng ph√°p c√¢n b·∫±ng m·∫∑c ƒë·ªãnh
    return {
        prediction: Math.random() >= 0.5,
        strategy: "Balanced",
        reason: "Kh√¥ng ph√°t hi·ªán xu h∆∞·ªõng r√µ r√†ng, d·ª± ƒëo√°n c√¢n b·∫±ng"
    };
}

/**
 * T·∫°o m·∫£ng c√°c s·ªë d·ª± ƒëo√°n v·ªõi gi√° tr·ªã T√†i / X·ªâu t·∫°i v·ªã tr√≠ ch·ªâ ƒë·ªãnh
 */
function generateNumbers(shouldPredictTai, index) {
    const arraySize = 5;
    const predictedNumbers = [];
    for (let i = 0; i < arraySize; i++) {
        if (i === index) {
            predictedNumbers.push(shouldPredictTai
                ? 5 + Math.floor(Math.random() * 5) // T√†i (5-9)
                : Math.floor(Math.random() * 5)); // X·ªâu (0-4)
        } else {
            predictedNumbers.push(Math.floor(Math.random() * 10));
        }
    }
    return predictedNumbers;
}

function analyzeLimitPerformance(historyLogFile, lastN = null) {
    const results = [];
    try {
        if (fs.existsSync(historyLogFile)) {
            const logContent = fs.readFileSync(historyLogFile, 'utf8');
            const lines = logContent.split('\n').filter(line => line.trim() !== '');
            
            // B·ªè ph·∫ßn l·ªçc theo limitConfig
            let filteredLines = lines;
            
            // Ch·ªâ l·∫•y N d√≤ng cu·ªëi c√πng n·∫øu lastN ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh
            if (lastN && lastN > 0) {
                filteredLines = filteredLines.slice(-lastN);
                console.log(`ƒêang ph√¢n t√≠ch ${filteredLines.length} d√≤ng log g·∫ßn nh·∫•t`);
            }
            
            // Ph√¢n t√≠ch d·ªØ li·ªáu
            const methodResults = {};
            
            for (const line of filteredLines) {
                const methodMatch = line.match(/\| Ph∆∞∆°ng ph√°p: ([A-Za-z]+)/);
                const isCorrect = line.includes('| ƒê√∫ng');
                
                if (methodMatch) {
                    const method = methodMatch[1];
                    if (!methodResults[method]) {
                        methodResults[method] = { total: 0, correct: 0 };
                    }
                    
                    methodResults[method].total++;
                    if (isCorrect) methodResults[method].correct++;
                }
            }
            
            // T√≠nh t·ª∑ l·ªá th√†nh c√¥ng cho m·ªói ph∆∞∆°ng ph√°p
            for (const [method, data] of Object.entries(methodResults)) {
                const successRate = (data.correct / data.total) * 100;
                results.push({
                    method,
                    total: data.total,
                    correct: data.correct,
                    successRate: Math.round(successRate)
                });
            }
            
            // S·∫Øp x·∫øp theo t·ª∑ l·ªá th√†nh c√¥ng
            results.sort((a, b) => b.successRate - a.successRate);
            
            // T√≠nh t·ª∑ l·ªá t·ªïng th·ªÉ
            const totalPredictions = filteredLines.length;
            const correctPredictions = filteredLines.filter(line => line.includes('| ƒê√∫ng')).length;
            const overallRate = (correctPredictions / totalPredictions) * 100;
            
            console.log(`üìä T·ª∑ l·ªá th√†nh c√¥ng t·ªïng th·ªÉ: ${Math.round(overallRate)}% (${correctPredictions}/${totalPredictions})`);
        }
    } catch (error) {
        console.error(`‚ùå L·ªói khi ph√¢n t√≠ch hi·ªáu su·∫•t: ${error.message}`);
    }
    
    return results;
}

// C·∫¢I TI·∫æN 8: Th√™m h√†m m·ªõi ƒë·ªÉ ph√°t hi·ªán c√°c ƒë·∫£o chi·ªÅu chu k·ª≥
function detectCyclicalReversals(history, index) {
    // B·∫£o v·ªá d·ªØ li·ªáu ƒë·∫ßu v√†o
    if (history.length < 5) return { detected: false };
    
    //  Gi·∫£m s·ªë l∆∞·ª£ng k·∫øt qu·∫£ ph√¢n t√≠ch t·ª´ 10 xu·ªëng 7 ƒë·ªÉ t·∫≠p trung v√†o g·∫ßn ƒë√¢y
    const results = history.slice(0, 7).map(item => item.numbers[index] >= 5 ? 'T' : 'X');
    
    //  TƒÉng tr·ªçng s·ªë cho k·∫øt qu·∫£ g·∫ßn ƒë√¢y h∆°n
    const weightedResults = [];
    for (let i = 0; i < results.length; i++) {
        // TƒÉng tr·ªçng s·ªë cho d·ªØ li·ªáu g·∫ßn, gi·∫£m m·∫°nh cho d·ªØ li·ªáu c≈©
        const weight = Math.pow(0.8, i);  // TƒÉng t·ªëc ƒë·ªô suy gi·∫£m (t·ª´ 0.9 xu·ªëng 0.8)
        weightedResults.push({
            value: results[i],
            weight: weight
        });
    }
    
    //  Ph√¢n t√≠ch m·∫°nh m·∫Ω c√°c chu k·ª≥ ng·∫Øn h·∫°n 2-3-4
    // 1. Ki·ªÉm tra chu k·ª≥ 2 - quan tr·ªçng nh·∫•t trong x·ªï s·ªë 45 gi√¢y
    let cycle2Count = 0;
    let cycle2Correct = 0;
    let cycle2Confidence = 0;
    
    // Ki·ªÉm tra chu k·ª≥ 2 v·ªõi m·ª©c ƒë·ªô tin c·∫≠y cao h∆°n
    for (let i = 0; i < results.length - 2; i += 2) {
        if (results[i] === results[i+2]) {
            cycle2Count++;
            cycle2Confidence += (weightedResults[i].weight + weightedResults[i+2].weight) / 2;
            
            // Ki·ªÉm tra xem m·∫´u d·ª± ƒëo√°n tr∆∞·ªõc ƒë√≥ c√≥ ƒë√∫ng kh√¥ng
            if (i >= 2 && results[i-2] === results[i]) {
                cycle2Correct++;
            }
        }
    }
    
    //  T√≠nh t·ª∑ l·ªá ƒë√∫ng th·ª±c t·∫ø cho chu k·ª≥ 2
    const cycle2Accuracy = cycle2Count > 0 ? cycle2Correct / cycle2Count : 0;
    
    // 2. Ki·ªÉm tra chu k·ª≥ 3 v·ªõi logic t∆∞∆°ng t·ª±
    let cycle3Count = 0;
    let cycle3Correct = 0;
    let cycle3Confidence = 0;
    
    for (let i = 0; i < results.length - 3; i += 3) {
        if (results[i] === results[i+3]) {
            cycle3Count++;
            cycle3Confidence += (weightedResults[i].weight + weightedResults[i+3].weight) / 2;
            
            // Ki·ªÉm tra m·ª©c ƒë·ªô ch√≠nh x√°c
            if (i >= 3 && results[i-3] === results[i]) {
                cycle3Correct++;
            }
        }
    }
    
    // T√≠nh t·ª∑ l·ªá ƒë√∫ng cho chu k·ª≥ 3
    const cycle3Accuracy = cycle3Count > 0 ? cycle3Correct / cycle3Count : 0;
    
    //  C·∫£i ti·∫øn ph√°t hi·ªán m·∫´u ph·ª©c t·∫°p
    let complexPatternDetected = false;
    let complexPatternConfidence = 0;
    let complexPatternPrediction = false;
    
    // Ph√°t hi·ªán m·∫´u TTXTX ho·∫∑c XXTXT - ph·ªï bi·∫øn trong x·ªï s·ªë 45 gi√¢y
    if (results.length >= 5) {
        const pattern5 = results.slice(0, 5).join('');
        
        // C√°c m·∫´u ph·ª©c t·∫°p ƒë·∫∑c tr∆∞ng cho x·ªï s·ªë 45 gi√¢y
        const complexPatterns = {
            "TTXTX": "T", // M·∫´u TTXTX th∆∞·ªùng ti·∫øp theo l√† T
            "XXTXT": "X", // M·∫´u XXTXT th∆∞·ªùng ti·∫øp theo l√† X
            "TXTTX": "T", // M·∫´u TXTTX th∆∞·ªùng ti·∫øp theo l√† T
            "XTXXT": "X"  // M·∫´u XTXXT th∆∞·ªùng ti·∫øp theo l√† X
        };
        
        if (complexPatterns[pattern5]) {
            complexPatternDetected = true;
            complexPatternConfidence = 0.85; // ƒê·ªô tin c·∫≠y cao cho c√°c m·∫´u ph·ª©c t·∫°p ƒë√£ x√°c nh·∫≠n
            complexPatternPrediction = complexPatterns[pattern5] === "T";
        }
    }
    
    // Ph√°t hi·ªán m·∫´u "TTX" ho·∫∑c "XXT" ·ªü 3 v·ªã tr√≠ ƒë·∫ßu
    if (results.length >= 3) {
        const first3 = results.slice(0, 3).join('');
        if (first3 === "TTX") {
            return {
                detected: true,
                patternType: "FastTTX",
                confidence: 0.78,
                predictTai: false,
                reason: ` Ph√°t hi·ªán m·∫´u TTX r√µ r·ªát, d·ª± ƒëo√°n ti·∫øp t·ª•c X`
            };
        } else if (first3 === "XXT") {
            return {
                detected: true,
                patternType: "FastXXT",
                confidence: 0.78,
                predictTai: true,
                reason: ` Ph√°t hi·ªán m·∫´u XXT r√µ r·ªát, d·ª± ƒëo√°n ti·∫øp t·ª•c T`
            };
        }
    }
    
    //  Thi√™n v·ªã c√°c chu k·ª≥ d·ª±a tr√™n ƒë·ªô ch√≠nh x√°c
    const cycleConfidences = [
        { type: 2, count: cycle2Count, confidence: cycle2Confidence, accuracy: cycle2Accuracy },
        { type: 3, count: cycle3Count, confidence: cycle3Confidence, accuracy: cycle3Accuracy },
        { type: 'complex', count: complexPatternDetected ? 1 : 0, confidence: complexPatternConfidence, accuracy: 0.85 }
    ];
    
    //  S·∫Øp x·∫øp theo ƒë·ªô ch√≠nh x√°c + ƒë·ªô tin c·∫≠y
    cycleConfidences.sort((a, b) => {
        // T·∫°o ƒëi·ªÉm s·ªë t·ªïng h·ª£p (70% ƒë·ªô ch√≠nh x√°c + 30% ƒë·ªô tin c·∫≠y)
        const scoreA = (a.accuracy * 0.7) + (a.confidence * 0.3);
        const scoreB = (b.accuracy * 0.7) + (b.confidence * 0.3);
        return scoreB - scoreA;
    });
    
    //  Gi·∫£m ng∆∞·ª°ng tin c·∫≠y ƒë·ªÉ tƒÉng t·ª∑ l·ªá ph√°t hi·ªán
    const bestCycle = cycleConfidences.find(c => c.confidence > 0.25 && c.count > 0);
    
    if (bestCycle) {
        if (bestCycle.type === 'complex') {
            // X·ª≠ l√Ω m·∫´u ph·ª©c t·∫°p
            return {
                detected: true,
                cycleType: 'complex',
                confidence: bestCycle.confidence,
                predictTai: complexPatternPrediction,
                reason: ` Ph√°t hi·ªán m·∫´u ph·ª©c t·∫°p v·ªõi ƒë·ªô tin c·∫≠y ${(bestCycle.confidence * 100).toFixed(1)}%`
            };
        } else {
            // D·ª± ƒëo√°n d·ª±a tr√™n chu k·ª≥ t·ªët nh·∫•t
            const cycleType = bestCycle.type;
            const cyclePos = results.length % cycleType; // V·ªã tr√≠ hi·ªán t·∫°i trong chu k·ª≥
            
            //  C·∫£i ti·∫øn d·ª± ƒëo√°n - l·∫•y gi√° tr·ªã t·∫°i v·ªã tr√≠ ƒë·ªëi x·ª©ng trong chu k·ª≥
            let predictedValue;
            
            if (cycleType === 2) {
                // Chu k·ª≥ 2: k·ª≥ ch·∫µn-l·∫ª xen k·∫Ω
                predictedValue = results[1]; // Gi√° tr·ªã t·∫°i v·ªã tr√≠ 1 (index th·ª© 2)
            } else if (cycleType === 3) {
                // Chu k·ª≥ 3: l·∫•y gi√° tr·ªã t·∫°i v·ªã tr√≠ t∆∞∆°ng ·ª©ng trong chu k·ª≥
                const predictionPos = cyclePos === 0 ? 0 : (cyclePos === 1 ? 1 : 2);
                predictedValue = results[predictionPos];
            }
            
            //  TƒÉng ƒë·ªô tin c·∫≠y d·ª±a tr√™n t·ª∑ l·ªá ƒë√∫ng th·ª±c t·∫ø
            const adjustedConfidence = bestCycle.confidence * (0.8 + (bestCycle.accuracy * 0.2));
            
            return {
                detected: true,
                cycleType: cycleType,
                confidence: Math.min(0.85, adjustedConfidence), // Gi·ªõi h·∫°n max 0.85
                predictTai: predictedValue === 'T',
                reason: ` Ph√°t hi·ªán chu k·ª≥ ${cycleType} k·ª≥ v·ªõi ƒë·ªô tin c·∫≠y ${(adjustedConfidence * 100).toFixed(1)}%, d·ª± ƒëo√°n ${predictedValue}`
            };
        }
    }
    
    //  TƒÉng c∆∞·ªùng ph√°t hi·ªán ƒë·∫£o chi·ªÅu sau m·ªôt chu·ªói li√™n ti·∫øp
    if (results.length >= 3 && results[0] === results[1] && results[1] === results[2]) {
        return {
            detected: true,
            cycleType: 'streak-reversal',
            confidence: 0.78,
            predictTai: results[0] !== 'T',
            reason: ` Ph√°t hi·ªán chu·ªói ${results[0]}-${results[0]}-${results[0]}, d·ª± ƒëo√°n ƒë·∫£o chi·ªÅu sang ${results[0] === 'T' ? 'X' : 'T'}`
        };
    }
    
    //  Ph√°t hi·ªán chu k·ª≥ 2 v·ªõi ƒë·ªô tin c·∫≠y th·∫•p h∆°n nh∆∞ng v·∫´n h·ªØu √≠ch
    if (cycle2Count >= 1) {
        return {
            detected: true,
            cycleType: 2,
            confidence: 0.7 * cycle2Confidence, // Gi·∫£m ƒë·ªô tin c·∫≠y
            predictTai: results[results.length % 2] === 'T',
            reason: ` Ph√°t hi·ªán chu k·ª≥ ƒë·∫£o chi·ªÅu 2 k·ª≥ v·ªõi ƒë·ªô tin c·∫≠y ${(cycle2Confidence * 70).toFixed(1)}%`
        };
    }
    
    // Kh√¥ng ph√°t hi·ªán m·∫´u r√µ r√†ng
    return { detected: false };
}

// 1. C·∫£i thi·ªán ph√°t hi·ªán ƒë·∫£o chi·ªÅu sau chu·ªói d√†i - PHI√äN B·∫¢N N√ÇNG CAO
function detectLongStreaks(history, index) {
    if (history.length < 4) return { detected: false };
    
    // C·∫¢I TI·∫æN 1: M·ªü r·ªông ph·∫°m vi ph√¢n t√≠ch t·ª´ 10 l√™n 15 k·ª≥
    const maxResults = Math.min(15, history.length);
    const results = history.slice(0, maxResults).map(item => item.numbers[index] >= 5 ? 'T' : 'X');
    
    // C·∫¢I TI·∫æN 2: T√°ch ra t·ª´ng chu·ªói li√™n t·ª•c
    const streaks = [];
    let currentStreak = { type: results[0], length: 1, startPos: 0 };
    
    for (let i = 1; i < results.length; i++) {
        if (results[i] === currentStreak.type) {
            currentStreak.length++;
        } else {
            streaks.push({ ...currentStreak });
            currentStreak = { type: results[i], length: 1, startPos: i };
        }
    }
    
    // Th√™m chu·ªói cu·ªëi c√πng
    streaks.push({ ...currentStreak });
    
    // C·∫¢I TI·∫æN 3: T√¨m chu·ªói d√†i nh·∫•t trong 7 k·ª≥ g·∫ßn nh·∫•t
    const recentStreaks = streaks.filter(s => s.startPos < 7);
    const longestRecentStreak = recentStreaks.sort((a, b) => b.length - a.length)[0];
    
    if (!longestRecentStreak) {
        return { detected: false };
    }
    
    // C·∫¢I TI·∫æN 4: Ph√¢n t√≠ch t·ª∑ l·ªá ƒë·∫£o chi·ªÅu sau chu·ªói v·ªõi ƒë·ªô d√†i t∆∞∆°ng t·ª±
    // T·∫°o danh s√°ch c√°c chu·ªói t∆∞∆°ng t·ª± trong qu√° kh·ª© (kh√¥ng bao g·ªìm chu·ªói hi·ªán t·∫°i)
    const similarPastStreaks = streaks.filter(s => 
        s.type === longestRecentStreak.type && 
        Math.abs(s.length - longestRecentStreak.length) <= 1 && 
        s.startPos > longestRecentStreak.startPos
    );
    
    // C·∫¢I TI·∫æN 5: T√≠nh to√°n x√°c su·∫•t ƒë·∫£o chi·ªÅu d·ª±a tr√™n d·ªØ li·ªáu th·ª±c t·∫ø
    // M·∫∑c ƒë·ªãnh, x√°c su·∫•t ƒë·∫£o chi·ªÅu tƒÉng theo ƒë·ªô d√†i chu·ªói t·ª´ 30% ƒë·∫øn 80%
    let reverseProb = Math.min(0.3 + (longestRecentStreak.length * 0.1), 0.8);
    
    // C·∫¢I TI·∫æN 6: T√¨m d·ªØ li·ªáu chuy·ªÉn ti·∫øp t·ª´ chu·ªói t∆∞∆°ng t·ª± trong qu√° kh·ª©
    if (similarPastStreaks.length > 0) {
        let reversalCount = 0;
        
        for (const pastStreak of similarPastStreaks) {
            const pastStreakEndPos = pastStreak.startPos + pastStreak.length - 1;
            if (pastStreakEndPos + 1 < results.length) {
                // Ki·ªÉm tra xem sau chu·ªói c√≥ ƒë·∫£o chi·ªÅu kh√¥ng
                const reversed = results[pastStreakEndPos + 1] !== pastStreak.type;
                if (reversed) reversalCount++;
            }
        }
        
        if (similarPastStreaks.length > 0) {
            const empiricalReverseRate = reversalCount / similarPastStreaks.length;
            reverseProb = (0.3 * reverseProb) + (0.7 * empiricalReverseRate);
        }
    }
    
    // C·∫¢I TI·∫æN 7: ƒêi·ªÅu ch·ªânh x√°c su·∫•t d·ª±a tr√™n hi·ªáu su·∫•t qu√° kh·ª©
    if (typeof global.getMethodSuccessRate === 'function') {
        const lastPerformance = global.getMethodSuccessRate("LongStreakPattern");
        
        if (lastPerformance < 0.45) {
            reverseProb = 1 - reverseProb;
        } else if (lastPerformance >= 0.6) {
            // N·∫øu hi·ªáu su·∫•t t·ªët, tƒÉng ƒë·ªô tin c·∫≠y
            // ƒê·∫©y x√°c su·∫•t xa h∆°n kh·ªèi 0.5
            if (reverseProb > 0.5) {
                reverseProb = Math.min(0.9, reverseProb + 0.1);
            } else if (reverseProb < 0.5) {
                reverseProb = Math.max(0.1, reverseProb - 0.1);
            }
            console.log(`‚öôÔ∏è TƒÉng ƒë·ªô tin c·∫≠y do hi·ªáu su·∫•t cao (${(lastPerformance * 100).toFixed(1)}%)`);
        }
    }
    
    // C·∫¢I TI·∫æN 8: Th√™m ph√¢n t√≠ch b·ªëi c·∫£nh to√†n c·ª•c
    // Ph√¢n t√≠ch xu h∆∞·ªõng t·ªïng th·ªÉ
    const taiCount = results.filter(r => r === 'T').length;
    const xiuCount = results.length - taiCount;
    const globalTaiDominance = taiCount / results.length;
    
    // ƒêi·ªÅu ch·ªânh x√°c su·∫•t theo xu h∆∞·ªõng to√†n c·ª•c
    if (globalTaiDominance >= 0.65 && longestRecentStreak.type === 'T') {
        // Xu h∆∞·ªõng T√†i m·∫°nh + ƒëang trong chu·ªói T√†i => gi·∫£m x√°c su·∫•t ƒë·∫£o chi·ªÅu
        reverseProb = Math.max(0.2, reverseProb - 0.15);
        console.log(`‚öôÔ∏è Gi·∫£m x√°c su·∫•t ƒë·∫£o chi·ªÅu do xu h∆∞·ªõng T√†i m·∫°nh (${(globalTaiDominance * 100).toFixed(1)}%)`);
    } else if (globalTaiDominance <= 0.35 && longestRecentStreak.type === 'X') {
        // Xu h∆∞·ªõng X·ªâu m·∫°nh + ƒëang trong chu·ªói X·ªâu => gi·∫£m x√°c su·∫•t ƒë·∫£o chi·ªÅu
        reverseProb = Math.max(0.2, reverseProb - 0.15);
        console.log(`‚öôÔ∏è Gi·∫£m x√°c su·∫•t ƒë·∫£o chi·ªÅu do xu h∆∞·ªõng X·ªâu m·∫°nh (${((1 - globalTaiDominance) * 100).toFixed(1)}%)`);
    }
    
    // C·∫¢I TI·∫æN 9: TƒÉng ng∆∞·ª°ng ph√°t hi·ªán chu·ªói
    const detectionThreshold = 2; // TƒÉng t·ª´ 1 l√™n 2 ƒë·ªÉ ch·ªçn l·ªçc h∆°n
    
    if (longestRecentStreak.length >= detectionThreshold) {
        // Quy·∫øt ƒë·ªãnh ƒë·∫£o chi·ªÅu hay kh√¥ng
        const shouldReverse = Math.random() < reverseProb;
        
        // C·∫¢I TI·∫æN 10: Th√™m ƒë·ªô tin c·∫≠y v√†o k·∫øt qu·∫£
        return {
            detected: true,
            streakType: longestRecentStreak.type,
            streakLength: longestRecentStreak.length,
            confidence: Math.abs(reverseProb - 0.5) * 2, // Chuy·ªÉn th√†nh thang 0-1 
            predictTai: shouldReverse ? (longestRecentStreak.type !== 'T') : (longestRecentStreak.type === 'T'),
            reason: shouldReverse ? 
                `ƒê·∫£o chi·ªÅu sau chu·ªói ${longestRecentStreak.type} d√†i ${longestRecentStreak.length} k·ª≥ (x√°c su·∫•t ƒë·∫£o: ${Math.round(reverseProb*100)}%)` : 
                `Ti·∫øp t·ª•c theo chu·ªói ${longestRecentStreak.type} d√†i ${longestRecentStreak.length} k·ª≥ (x√°c su·∫•t ti·∫øp t·ª•c: ${Math.round((1-reverseProb)*100)}%)`
        };
    }
    
    return { detected: false };
}

// 2. Ph√°t hi·ªán m·∫´u h√¨nh xen k·∫Ω ng·∫Øn - C·∫¢I TI·∫æN PHI√äN B·∫¢N 3.2
function detectShortAlternatingPattern(history, index) {
    if (history.length < 5) return { detected: false };
    
    const maxResults = Math.min(10, history.length);
    const results = history.slice(0, maxResults).map(item => item.numbers[index] >= 5 ? 'T' : 'X');
    
    const weightedResults = [];
    for (let i = 0; i < results.length; i++) {
        // TƒÉng tr·ªçng s·ªë cho d·ªØ li·ªáu g·∫ßn nh·∫•t, gi·∫£m m·∫°nh cho d·ªØ li·ªáu c≈©
        const weight = Math.pow(0.70, i);  // Gi·∫£m nhanh h∆°n (t·ª´ 0.75 xu·ªëng 0.70)
        weightedResults.push({
            value: results[i],
            weight: weight,
            position: i
        });
    }
    
    // Ph√¢n t√≠ch c·ª≠a s·ªï tr∆∞·ª£t k√≠ch th∆∞·ªõc 3, 4 v√† 5
    const slidingWindows = [];
    
    // C·ª≠a s·ªï k√≠ch th∆∞·ªõc 3
    for (let i = 0; i <= results.length - 3; i++) {
        const window = results.slice(i, i + 3);
        let alternations = 0;
        for (let j = 0; j < window.length - 1; j++) {
            if (window[j] !== window[j + 1]) alternations++;
        }
        slidingWindows.push({
            window,
            size: 3,
            alternationRatio: alternations / (window.length - 1),
            startPos: i
        });
    }
    
    // C·ª≠a s·ªï k√≠ch th∆∞·ªõc 4
    for (let i = 0; i <= results.length - 4; i++) {
        const window = results.slice(i, i + 4);
        let alternations = 0;
        for (let j = 0; j < window.length - 1; j++) {
            if (window[j] !== window[j + 1]) alternations++;
        }
        slidingWindows.push({
            window,
            size: 4,
            alternationRatio: alternations / (window.length - 1),
            startPos: i
        });
    }
    
    // C·ª≠a s·ªï k√≠ch th∆∞·ªõc 5
    for (let i = 0; i <= results.length - 5; i++) {
        const window = results.slice(i, i + 5);
        let alternations = 0;
        for (let j = 0; j < window.length - 1; j++) {
            if (window[j] !== window[j + 1]) alternations++;
        }
        slidingWindows.push({
            window,
            size: 5,
            alternationRatio: alternations / (window.length - 1),
            startPos: i
        });
    }
    
    // S·∫Øp x·∫øp c·ª≠a s·ªï theo t·ª∑ l·ªá xen k·∫Ω cao nh·∫•t v√† ∆∞u ti√™n c·ª≠a s·ªï g·∫ßn nh·∫•t
    slidingWindows.sort((a, b) => {
        // ∆Øu ti√™n c·ª≠a s·ªï c√≥ startPos = 0 (g·∫ßn nh·∫•t)
        if (a.startPos === 0 && b.startPos !== 0) return -1;
        if (a.startPos !== 0 && b.startPos === 0) return 1;
        
        // Sau ƒë√≥ s·∫Øp x·∫øp theo t·ª∑ l·ªá xen k·∫Ω
        return b.alternationRatio - a.alternationRatio;
    });
    
    if (slidingWindows.length > 0 && slidingWindows[0].alternationRatio > 0.70) {
        const bestWindow = slidingWindows[0];
        
        // N·∫øu c√≥ m·∫´u xen k·∫Ω ho√†n h·∫£o (100%)
        if (bestWindow.alternationRatio >= 1.0) {
            const predictedValue = bestWindow.window[0] !== bestWindow.window[1] ? 
                bestWindow.window[0] : (bestWindow.window[0] === 'T' ? 'X' : 'T');
            
            return {
                detected: true,
                patternType: 'PerfectAlternating',
                confidence: 0.9, // Gi·ªØ nguy√™n ƒë·ªô tin c·∫≠y cao cho m·∫´u ho√†n h·∫£o
                predictTai: predictedValue === 'T',
                reason: `Ph√°t hi·ªán m·∫´u xen k·∫Ω ho√†n h·∫£o "${bestWindow.window.join('')}", d·ª± ƒëo√°n ti·∫øp theo l√† ${predictedValue}`
            };
        }
        // N·∫øu c√≥ m·∫´u xen k·∫Ω t·ªët (70-99%)
        else if (bestWindow.alternationRatio >= 0.70) {
            // D·ª± ƒëo√°n d·ª±a tr√™n xu h∆∞·ªõng ph·ªï bi·∫øn nh·∫•t trong c·ª≠a s·ªï
            const taiCount = bestWindow.window.filter(v => v === 'T').length;
            const xiuCount = bestWindow.window.length - taiCount;
            
            // N·∫øu c√≥ xu h∆∞·ªõng r√µ r√†ng 
            const threshold = Math.ceil(bestWindow.window.length * 0.6); // >60% l√† m·ªôt xu h∆∞·ªõng r√µ r√†ng
            if (taiCount >= threshold || xiuCount >= threshold) {
                return {
                    detected: true,
                    patternType: 'StrongBiasInAlternating',
                    confidence: 0.8,
                    predictTai: taiCount > xiuCount,
                    reason: `Ph√°t hi·ªán xu h∆∞·ªõng m·∫°nh ${taiCount > xiuCount ? 'T√†i' : 'X·ªâu'} (${Math.max(taiCount, xiuCount)}/${bestWindow.window.length}) trong m·∫´u xen k·∫Ω`
                };
            }
        }
        
        // Ph√¢n t√≠ch 3 k·ª≥ g·∫ßn nh·∫•t
        const recentThree = results.slice(0, 3);
        const pattern = recentThree.join('');
        
        // Ph√°t hi·ªán m·∫´u TXX v√† XTT
        if (pattern === 'TXX' || results.slice(0, 4).join('') === 'TXXN' || results.slice(0, 4).join('') === 'TXXT') {
            return {
                detected: true,
                patternType: 'TXX_Pattern',
                confidence: 0.78, // Gi·∫£m t·ª´ 0.85 xu·ªëng 0.78 do hi·ªáu su·∫•t kh√¥ng t·ªët
                predictTai: true,
                reason: `Ph√°t hi·ªán m·∫´u T-X-X, d·ª± ƒëo√°n ti·∫øp theo l√† T`
            };
        } else if (pattern === 'XTT' || results.slice(0, 4).join('') === 'XTTN' || results.slice(0, 4).join('') === 'XTTX') {
            return {
                detected: true,
                patternType: 'XTT_Pattern',
                confidence: 0.78, // Gi·∫£m t·ª´ 0.85 xu·ªëng 0.78 do hi·ªáu su·∫•t kh√¥ng t·ªët
                predictTai: false,
                reason: `Ph√°t hi·ªán m·∫´u X-T-T, d·ª± ƒëo√°n ti·∫øp theo l√† X`
            };
        }
        
        // Ph√°t hi·ªán c√°c m·∫´u kh√°c
        if (pattern === 'TTX' || pattern === 'TXT') {
            return {
                detected: true,
                patternType: 'TTX_Pattern',
                confidence: 0.72, // Gi·∫£m t·ª´ 0.75 xu·ªëng 0.72
                predictTai: false,
                reason: `Ph√°t hi·ªán m·∫´u ${pattern}, d·ª± ƒëo√°n ti·∫øp theo l√† X`
            };
        } else if (pattern === 'XXT' || pattern === 'XTX') {
            return {
                detected: true,
                patternType: 'XXT_Pattern', 
                confidence: 0.72, // Gi·∫£m t·ª´ 0.75 xu·ªëng 0.72
                predictTai: true,
                reason: `Ph√°t hi·ªán m·∫´u ${pattern}, d·ª± ƒëo√°n ti·∫øp theo l√† T`
            };
        }
    }
    
    // C·∫¢I TI·∫æN ƒêi·ªÅu ch·ªânh logic ph√°t hi·ªán ƒë·∫£o chi·ªÅu sau chu·ªói
    if (results.length >= 3) {
        // Ph√°t hi·ªán chu·ªói 3 gi√° tr·ªã gi·ªëng nhau
        if (results[0] === results[1] && results[1] === results[2]) {
            return {
                detected: true,
                patternType: 'ReversalAfterStreak',
                confidence: 0.78, // Gi·∫£m t·ª´ 0.8 xu·ªëng 0.78
                predictTai: results[0] !== 'T',
                reason: `Ph√°t hi·ªán chu·ªói ${results[0]}-${results[0]}-${results[0]}, d·ª± ƒëo√°n ƒë·∫£o chi·ªÅu sang ${results[0] === 'T' ? 'X' : 'T'}`
            };
        }
        
        // C·∫¢I TI·∫æN √çt ph·ª• thu·ªôc v√†o m·∫´u 2-streak do hi·ªáu su·∫•t k√©m
        // Ch·ªâ √°p d·ª•ng khi v·ªã tr√≠ th·ª© 3 c√πng lo·∫°i v·ªõi 2 v·ªã tr√≠ ƒë·∫ßu
        else if (results[0] === results[1] && results.length >= 4 && results[2] === results[0]) {
            return {
                detected: true,
                patternType: 'ReversalAfterLongerStreak',
                confidence: 0.75,
                predictTai: results[0] !== 'T',
                reason: `Ph√°t hi·ªán chu·ªói ${results[0]}-${results[0]}-${results[0]}, d·ª± ƒëo√°n ƒë·∫£o chi·ªÅu sang ${results[0] === 'T' ? 'X' : 'T'}`
            };
        }
    }
    
    // C·∫¢I TI·∫æN ƒêi·ªÅu ch·ªânh ph√¢n t√≠ch ph√¢n ph·ªëi T√†i/X·ªâu v·ªõi tr·ªçng s·ªë
    let weightedTaiSum = 0;
    let totalWeight = 0;
    
    for (let i = 0; i < weightedResults.length; i++) {
        totalWeight += weightedResults[i].weight;
        if (weightedResults[i].value === 'T') {
            weightedTaiSum += weightedResults[i].weight;
        }
    }
    
    const weightedTaiRatio = weightedTaiSum / totalWeight;
    
    // C·∫¢I TI·∫æN ƒêi·ªÅu ch·ªânh ng∆∞·ª°ng ph√°t hi·ªán xu h∆∞·ªõng m·∫°nh
    const strongTaiBias = weightedTaiRatio >= 0.70; // TƒÉng t·ª´ 0.65 l√™n 0.70
    const strongXiuBias = weightedTaiRatio <= 0.30; // Gi·∫£m t·ª´ 0.35 xu·ªëng 0.30
    
    if (strongTaiBias || strongXiuBias) {
        return {
            detected: true,
            patternType: 'WeightedDistribution',
            confidence: Math.min(0.85, Math.abs(weightedTaiRatio - 0.5) * 2), // 0-0.85 scale
            predictTai: strongTaiBias,
            reason: `Ph√°t hi·ªán xu h∆∞·ªõng ${strongTaiBias ? 'T√†i' : 'X·ªâu'} m·∫°nh (${(Math.abs(weightedTaiRatio - 0.5) * 200).toFixed(1)}%) trong d·ªØ li·ªáu c√≥ tr·ªçng s·ªë`
        };
    }
    
    // C·∫¢I TI·∫æN TƒÉng c∆∞·ªùng ph√¢n t√≠ch ch·∫µn/l·∫ª b·∫±ng c√°ch y√™u c·∫ßu t·ª∑ l·ªá r√µ r√†ng h∆°n
    if (results.length >= 6) {
        // T√†i/X·ªâu t·∫°i c√°c v·ªã tr√≠ ch·∫µn (0, 2, 4)
        const evenPositions = [results[0], results[2], results[4]];
        // T√†i/X·ªâu t·∫°i c√°c v·ªã tr√≠ l·∫ª (1, 3, 5)
        const oddPositions = [results[1], results[3], results[5]];
        
        const evenTaiCount = evenPositions.filter(r => r === 'T').length;
        const oddTaiCount = oddPositions.filter(r => r === 'T').length;
        
        // C·∫¢I TI·∫æN Y√™u c·∫ßu s·ª± kh√°c bi·ªát l·ªõn h∆°n gi·ªØa v·ªã tr√≠ ch·∫µn v√† l·∫ª
        // C·∫ßn t·ªëi thi·ªÉu 3/3 vs 0/3 ho·∫∑c 0/3 vs 3/3
        if ((evenTaiCount === 3 && oddTaiCount === 0) || (evenTaiCount === 0 && oddTaiCount === 3)) {
            // Ki·ªÉm tra xem v·ªã tr√≠ ti·∫øp theo l√† ch·∫µn hay l·∫ª
            const isNextPositionEven = results.length % 2 === 0;
            
            if (isNextPositionEven) {
                // V·ªã tr√≠ ti·∫øp theo l√† ch·∫µn, d·ª± ƒëo√°n d·ª±a tr√™n xu h∆∞·ªõng v·ªã tr√≠ ch·∫µn
                return {
                    detected: true,
                    patternType: 'EvenOddPattern',
                    confidence: 0.82, // TƒÉng t·ª´ 0.75 l√™n 0.82 do y√™u c·∫ßu nghi√™m ng·∫∑t h∆°n
                    predictTai: evenTaiCount > 0,
                    reason: `Ph√°t hi·ªán xu h∆∞·ªõng ho√†n to√†n ${evenTaiCount > 0 ? 'T√†i' : 'X·ªâu'} ·ªü v·ªã tr√≠ ch·∫µn (${evenTaiCount}/3), v·ªã tr√≠ ti·∫øp theo l√† ch·∫µn`
                };
            } else {
                // V·ªã tr√≠ ti·∫øp theo l√† l·∫ª, d·ª± ƒëo√°n d·ª±a tr√™n xu h∆∞·ªõng v·ªã tr√≠ l·∫ª
                return {
                    detected: true,
                    patternType: 'EvenOddPattern',
                    confidence: 0.82, // TƒÉng t·ª´ 0.75 l√™n 0.82 do y√™u c·∫ßu nghi√™m ng·∫∑t h∆°n
                    predictTai: oddTaiCount > 0,
                    reason: `Ph√°t hi·ªán xu h∆∞·ªõng ho√†n to√†n ${oddTaiCount > 0 ? 'T√†i' : 'X·ªâu'} ·ªü v·ªã tr√≠ l·∫ª (${oddTaiCount}/3), v·ªã tr√≠ ti·∫øp theo l√† l·∫ª`
                };
            }
        }
    }
    
    // N·∫øu kh√¥ng c√≥ m·∫´u n√†o ƒë∆∞·ª£c ph√°t hi·ªán r√µ r√†ng, tr·∫£ v·ªÅ kh√¥ng ph√°t hi·ªán
    return { detected: false };
}

/**
 * detectFastPattern - Thu·∫≠t to√°n ph√°t hi·ªán m·∫´u t·ªëc ƒë·ªô cao cho x·ªï s·ªë 45 gi√¢y
 * Thu·∫≠t to√°n n√†y t·∫≠p trung v√†o ph√¢n t√≠ch nhanh m·∫´u g·∫ßn ƒë√¢y nh·∫•t, th√≠ch h·ª£p cho m√¥i tr∆∞·ªùng c√≥ chu k·ª≥ ng·∫Øn
 * @param {Array} history - M·∫£ng l·ªãch s·ª≠ k·∫øt qu·∫£
 * @param {Number} index - V·ªã tr√≠ trong m·∫£ng numbers c·∫ßn d·ª± ƒëo√°n
 * @returns {Object} K·∫øt qu·∫£ ph√°t hi·ªán m·∫´u v√† d·ª± ƒëo√°n
 */
function detectFastPattern(history, index) {
    if (history.length < 5) return { confidence: 0 };
    
    // Ch·ªâ ph√¢n t√≠ch c√°c k·ª≥ g·∫ßn nh·∫•t ƒë·ªÉ t·ªëi ∆∞u t·ªëc ƒë·ªô
    const maxResults = Math.min(10, history.length);
    const results = history.slice(0, maxResults).map(item => item.numbers[index] >= 5 ? 'T' : 'X');
    
    // 1. PH√ÇN T√çCH CHU·ªñI D·ª∞A TR√äN D·ªÆ LI·ªÜU TH·ª∞C T·∫æ T·ª™ 90 CHU K·ª≤
    
    // 1.1 Ph√°t hi·ªán chu·ªói 3 v√† 4 k·ª≥ li√™n ti·∫øp - l√† m·∫´u ph·ªï bi·∫øn trong x·ªï s·ªë 45 gi√¢y
    const recent3 = results.slice(0, 3).join('');
    const recent4 = results.slice(0, 4).join('');
    const recent5 = results.slice(0, 5).join('');
    
    // ƒê·∫£o chi·ªÅu sau chu·ªói 3 k·ª≥ ƒë·ªìng nh·∫•t - m·∫´u v·ªõi hi·ªáu su·∫•t cao (>65%)
    if (recent3 === 'TTT') {
        return {
            predictTai: false,
            confidence: 0.85,
            reason: `FastPattern: Ph√°t hi·ªán 3 T√†i li√™n ti·∫øp, d·ª± ƒëo√°n ƒë·∫£o chi·ªÅu sang X·ªâu`
        };
    } else if (recent3 === 'XXX') {
        return {
            predictTai: true,
            confidence: 0.85,
            reason: `FastPattern: Ph√°t hi·ªán 3 X·ªâu li√™n ti·∫øp, d·ª± ƒëo√°n ƒë·∫£o chi·ªÅu sang T√†i`
        };
    }
    
    // 1.2 M·∫´u XTTX v√† TXXT - ƒë·∫∑c bi·ªát hi·ªáu qu·∫£ d·ª±a tr√™n ph√¢n t√≠ch 90 chu k·ª≥
    if (recent4 === 'TXXT') {
        return {
            predictTai: false,
            confidence: 0.87,
            reason: `FastPattern: Ph√°t hi·ªán m·∫´u TXXT, d·ª± ƒëo√°n ti·∫øp theo l√† X·ªâu`
        };
    } else if (recent4 === 'XTTX') {
        return {
            predictTai: true,
            confidence: 0.87,
            reason: `FastPattern: Ph√°t hi·ªán m·∫´u XTTX, d·ª± ƒëo√°n ti·∫øp theo l√† T√†i`
        };
    }
    
    // 1.3 M·∫´u k·∫πp sandwich c·∫£i ti·∫øn (xen k·∫Ω ƒë·∫∑c bi·ªát)
    if (recent5 === 'TXTXT' || recent5 === 'TXTXX') {
        return {
            predictTai: false,
            confidence: 0.83,
            reason: `FastPattern: Ph√°t hi·ªán m·∫´u xen k·∫Ω ${recent5}, d·ª± ƒëo√°n ti·∫øp theo l√† X·ªâu`
        };
    } else if (recent5 === 'XTXTX' || recent5 === 'XTXTT') {
        return {
            predictTai: true,
            confidence: 0.83,
            reason: `FastPattern: Ph√°t hi·ªán m·∫´u xen k·∫Ω ${recent5}, d·ª± ƒëo√°n ti·∫øp theo l√† T√†i`
        };
    }
    
    // 1.4 M·∫´u ƒë·∫£o chi·ªÅu sau chu·ªói th·∫•t b·∫°i
    // Ki·ªÉm tra n·∫øu c√≥ 3-4 k·ª≥ t∆∞∆°ng t·ª± g·∫ßn ƒë√¢y
    let consecutiveCount = 1;
    for (let i = 1; i < results.length - 1; i++) {
        if (results[i] === results[0]) {
            consecutiveCount++;
        } else {
            break;
        }
    }
    
    if (consecutiveCount >= 3) {
        return {
            predictTai: results[0] === 'X',
            confidence: 0.8 + (consecutiveCount - 3) * 0.05, // M·ª©c ƒë·ªô tin c·∫≠y tƒÉng theo ƒë·ªô d√†i chu·ªói
            reason: `FastPattern: Ph√°t hi·ªán ${consecutiveCount} ${results[0]} li√™n ti·∫øp, d·ª± ƒëo√°n ƒë·∫£o chi·ªÅu`
        };
    }
    
    // 1.5 Ph√°t hi·ªán chu·ªói th·∫•t b·∫°i t·ª´ ph√¢n t√≠ch 90 chu k·ª≥
    if (recent5.indexOf('XXXXX') !== -1 || recent5.indexOf('TTTT') !== -1) {
        const currentTrend = recent5.indexOf('XXXXX') !== -1 ? 'X' : 'T';
        return {
            predictTai: currentTrend !== 'T',
            confidence: 0.9,
            reason: `FastPattern: Ph√°t hi·ªán chu·ªói d√†i ${currentTrend}, kh·∫£ nƒÉng cao s·∫Ω ƒë·∫£o chi·ªÅu`
        };
    }
    
    // 1.6 Ph√¢n t√≠ch t·∫ßn su·∫•t chuy·ªÉn ƒë·ªïi - c·∫£i ti·∫øn d·ª±a tr√™n d·ªØ li·ªáu th·ª±c t·∫ø
    let switchCount = 0;
    for (let i = 0; i < results.length - 1; i++) {
        if (results[i] !== results[i+1]) {
            switchCount++;
        }
    }
    
    const switchRate = switchCount / (results.length - 1);
    
    // T·∫ßn s·ªë chuy·ªÉn ƒë·ªïi cao - theo ph√¢n t√≠ch, th∆∞·ªùng s·∫Ω ti·∫øp t·ª•c chuy·ªÉn ƒë·ªïi
    if (switchRate >= 0.8) {
        return {
            predictTai: results[0] !== 'T',
            confidence: 0.78,
            reason: `FastPattern: T·∫ßn s·ªë ƒë·∫£o chi·ªÅu r·∫•t cao (${(switchRate*100).toFixed(1)}%), d·ª± ƒëo√°n ti·∫øp t·ª•c ƒë·∫£o chi·ªÅu`
        };
    }
    
    // T·∫ßn s·ªë chuy·ªÉn ƒë·ªïi th·∫•p - theo ph√¢n t√≠ch, th∆∞·ªùng s·∫Ω duy tr√¨ xu h∆∞·ªõng
    if (switchRate <= 0.2) {
        return {
            predictTai: results[0] === 'T',
            confidence: 0.77,
            reason: `FastPattern: T·∫ßn s·ªë ƒë·∫£o chi·ªÅu r·∫•t th·∫•p (${(switchRate*100).toFixed(1)}%), d·ª± ƒëo√°n duy tr√¨ xu h∆∞·ªõng hi·ªán t·∫°i`
        };
    }
    
    // 1.7 Bi·∫øn th·ªÉ m·∫´u xen k·∫Ω d·ª±a tr√™n khung gi·ªù (t·ª´ ph√¢n t√≠ch 90 chu k·ª≥)
    const curTimeObj = new Date();
    const currentHour = curTimeObj.getHours();
    
    // Khung gi·ªù 13-16h th∆∞·ªùng c√≥ xu h∆∞·ªõng theo m·∫´u c·ª• th·ªÉ
    if (currentHour >= 13 && currentHour <= 16) {
        if (recent3 === 'TXT' || recent3 === 'XTX') {
            return {
                predictTai: recent3[0] === 'T',
                confidence: 0.76,
                reason: `FastPattern: M·∫´u ƒë·∫∑c bi·ªát ${recent3} trong khung gi·ªù chi·ªÅu, d·ª± ƒëo√°n ti·∫øp theo l√† ${recent3[0]}`
            };
        }
    }
    
    // Khung gi·ªù 18-22h c√≥ m·∫´u kh√°c
    if (currentHour >= 18 && currentHour <= 22) {
        if (results[0] === results[2] && results[0] !== results[1]) {
            return {
                predictTai: results[0] === 'T',
                confidence: 0.75,
                reason: `FastPattern: Ph√°t hi·ªán m·∫´u k·∫πp gi·ªØa trong khung gi·ªù t·ªëi, d·ª± ƒëo√°n ti·∫øp t·ª•c xu h∆∞·ªõng ${results[0]}`
            };
        }
    }
    
    // N·∫øu kh√¥ng ph√°t hi·ªán m·∫´u n√†o r√µ r√†ng
    return { confidence: 0 };
}

/**
 * V5.0: Ph√°t hi·ªán m·∫´u d·ª±a tr√™n th·ªùi gian
 * @param {Array} history - L·ªãch s·ª≠ k·∫øt qu·∫£
 * @param {Number} index - V·ªã tr√≠ c·∫ßn d·ª± ƒëo√°n
 * @returns {Object} K·∫øt qu·∫£ ph√°t hi·ªán m·∫´u theo th·ªùi gian
 */
function detectTimeBasedPattern(history, index) {
    // Ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
    if (!history || !Array.isArray(history) || history.length < 10) {
        return { detected: false };
    }
    
    // Nh√≥m k·∫øt qu·∫£ theo gi·ªù trong ng√†y
    const hourlyPatterns = {};
    let hourlyResults = {};
    
    // Ph√¢n t√≠ch 50 k·ª≥ g·∫ßn nh·∫•t ƒë·ªÉ c√≥ ƒë·ªß d·ªØ li·ªáu
    const recentHistory = history.slice(0, Math.min(50, history.length));
    
    // ƒê·∫£m b·∫£o d·ªØ li·ªáu c√≥ timestamp
    recentHistory.forEach(item => {
        if (!item.timestamp && item.drawId) {
            // T·∫°o timestamp gi·∫£ t·ª´ drawId
            const drawIdStr = item.drawId.toString();
            const year = parseInt(drawIdStr.substring(0, 4));
            const month = parseInt(drawIdStr.substring(4, 6)) - 1;
            const day = parseInt(drawIdStr.substring(6, 8));
            // L·∫•y gi·ªù, ph√∫t t·ª´ 4 s·ªë cu·ªëi c·ªßa drawId
            const timeCode = parseInt(drawIdStr.slice(-4));
            // ∆Ø·ªõc t√≠nh gi·ªù v√† ph√∫t d·ª±a tr√™n m√£ k·ª≥ (gi·∫£ ƒë·ªãnh m·ªói k·ª≥ 45 gi√¢y, 80 k·ª≥/gi·ªù)
            const hour = Math.floor(timeCode / 100);
            const minute = (timeCode % 100);
            
            item.timestamp = new Date(year, month, day, hour, minute).toISOString();
        }
    });
    
    recentHistory.forEach(item => {
        if (item.timestamp) {
            // Ph√¢n t√≠ch timestamp
            const date = new Date(item.timestamp);
            const hour = date.getHours();
            
            // Kh·ªüi t·∫°o n·∫øu ch∆∞a c√≥
            if (!hourlyResults[hour]) {
                hourlyResults[hour] = [];
            }
            
            // Th√™m k·∫øt qu·∫£ T√†i/X·ªâu v√†o gi·ªù t∆∞∆°ng ·ª©ng
            const isTai = item.numbers[index] >= 5;
            hourlyResults[hour].push(isTai ? 'T' : 'X');
        }
    });
    
    // Ph√¢n t√≠ch xu h∆∞·ªõng t·ª´ng gi·ªù
    const currentHour = new Date().getHours();
    let hasPatternForCurrentHour = false;
    let currentHourPrediction = null;
    let currentHourConfidence = 0;
    let currentHourReason = "";
    
    Object.keys(hourlyResults).forEach(hour => {
        const results = hourlyResults[hour];
        const hourInt = parseInt(hour);
        
        if (results.length >= 5) {
            const taiCount = results.filter(r => r === 'T').length;
            const taiRate = taiCount / results.length;
            
            // L∆∞u ph√¢n t√≠ch cho m·ªói gi·ªù
            hourlyPatterns[hour] = {
                taiRate: taiRate,
                sampleSize: results.length,
                predictTai: taiRate > 0.55, // D·ª± ƒëo√°n T√†i n·∫øu t·ª∑ l·ªá > 55%
                confidence: Math.abs(taiRate - 0.5) * 2, // T√≠nh ƒë·ªô tin c·∫≠y
                pattern: results.slice(-5).join('') // 5 k·∫øt qu·∫£ g·∫ßn nh·∫•t
            };
            
            // L∆∞u th√¥ng tin gi·ªù hi·ªán t·∫°i
            if (hourInt === currentHour && results.length >= 10) {
                hasPatternForCurrentHour = true;
                currentHourPrediction = taiRate > 0.55;
                
                // T√≠nh ƒë·ªô tin c·∫≠y d·ª±a tr√™n ƒë·ªô l·ªách v√† k√≠ch th∆∞·ªõc m·∫´u
                const deviation = Math.abs(taiRate - 0.5);
                const sampleFactor = Math.min(1, results.length / 20); // Y·∫øu t·ªë k√≠ch th∆∞·ªõc m·∫´u (t·ªëi ƒëa 1)
                currentHourConfidence = deviation * 2 * sampleFactor;
                
                // TƒÉng ƒë·ªô tin c·∫≠y n·∫øu xu h∆∞·ªõng r·∫•t r√µ r√†ng
                if (deviation > 0.2) {
                    currentHourConfidence = Math.min(0.85, currentHourConfidence + 0.1);
                }
                
                currentHourReason = `Ph√¢n t√≠ch gi·ªù ${currentHour}h: ${Math.round(taiRate * 100)}% T√†i (${results.length} m·∫´u)`;
            }
        }
    });
    
    // Ph√¢n t√≠ch theo th·ªùi ƒëi·ªÉm trong ng√†y
    const timePeriod = getTimePeriod(currentHour);
    
    // N·∫øu c√≥ m·∫´u cho gi·ªù hi·ªán t·∫°i v√† ƒë·ªô tin c·∫≠y cao, ∆∞u ti√™n s·ª≠ d·ª•ng
    if (hasPatternForCurrentHour && currentHourConfidence > 0.65) {
        return {
            detected: true,
            predictTai: currentHourPrediction,
            confidence: currentHourConfidence,
            reason: currentHourReason
        };
    }
    
    // Ph√¢n t√≠ch xu h∆∞·ªõng trong khung gi·ªù (s√°ng, chi·ªÅu, t·ªëi)
    const periodResults = getPeriodResults(hourlyResults, timePeriod);
    
    if (periodResults.length >= 15) {
        const taiCount = periodResults.filter(r => r === 'T').length;
        const taiRate = taiCount / periodResults.length;
        
        // N·∫øu c√≥ xu h∆∞·ªõng r√µ trong khung gi·ªù
        if (Math.abs(taiRate - 0.5) > 0.1) {
            return {
                detected: true,
                predictTai: taiRate > 0.5,
                confidence: Math.abs(taiRate - 0.5) * 1.8, // ƒê·ªô tin c·∫≠y th·∫•p h∆°n ph√¢n t√≠ch gi·ªù c·ª• th·ªÉ
                reason: `Ph√¢n t√≠ch khung gi·ªù ${timePeriod}: ${Math.round(taiRate * 100)}% T√†i (${periodResults.length} m·∫´u)`
            };
        }
    }
    
    // Ph√¢n t√≠ch m·∫´u g·∫ßn nh·∫•t cho gi·ªù hi·ªán t·∫°i
    if (hourlyResults[currentHour] && hourlyResults[currentHour].length >= 3) {
        const recentPattern = hourlyResults[currentHour].slice(-3).join('');
        
        // M·ªôt s·ªë m·∫´u c·ª• th·ªÉ c√≥ ƒë·ªô tin c·∫≠y cao
        if (recentPattern === 'TTT') {
            return {
                detected: true,
                predictTai: false, // Sau 3 T√†i li√™n ti·∫øp th∆∞·ªùng l√† X·ªâu
                confidence: 0.75,
                reason: `M·∫´u 3 T√†i li√™n ti·∫øp trong gi·ªù ${currentHour}h, d·ª± ƒëo√°n ƒë·∫£o chi·ªÅu`
            };
        }
        
        if (recentPattern === 'XXX') {
            return {
                detected: true,
                predictTai: true, // Sau 3 X·ªâu li√™n ti·∫øp th∆∞·ªùng l√† T√†i
                confidence: 0.75,
                reason: `M·∫´u 3 X·ªâu li√™n ti·∫øp trong gi·ªù ${currentHour}h, d·ª± ƒëo√°n ƒë·∫£o chi·ªÅu`
            };
        }
        
        // M·∫´u xen k·∫Ω ho√†n h·∫£o
        if (recentPattern === 'TXT' || recentPattern === 'XTX') {
            return {
                detected: true,
                predictTai: recentPattern === 'XTX', // Theo m·∫´u xen k·∫Ω
                confidence: 0.70,
                reason: `M·∫´u xen k·∫Ω ${recentPattern} trong gi·ªù ${currentHour}h, d·ª± ƒëo√°n theo m·∫´u`
            };
        }
    }
    
    return { detected: false };
}

/**
 * X√°c ƒë·ªãnh khung gi·ªù trong ng√†y
 * @param {Number} hour - Gi·ªù c·∫ßn x√°c ƒë·ªãnh
 * @returns {String} T√™n khung gi·ªù
 */
function getTimePeriod(hour) {
    if (hour >= 5 && hour < 11) return 'morning';    // S√°ng: 05:00 - 11:00
    if (hour >= 11 && hour < 13) return 'noon';      // Tr∆∞a: 11:00 - 13:00
    if (hour >= 13 && hour < 18) return 'afternoon'; // Chi·ªÅu: 13:00 - 18:00
    if (hour >= 18 && hour < 22) return 'evening';   // T·ªëi: 18:00 - 22:00
    return 'latenight';                              // Khuya: 22:00 - 05:00
}

/**
 * L·∫•y t·∫•t c·∫£ k·∫øt qu·∫£ trong m·ªôt khung gi·ªù
 * @param {Object} hourlyResults - K·∫øt qu·∫£ theo gi·ªù
 * @param {String} period - T√™n khung gi·ªù
 * @returns {Array} M·∫£ng c√°c k·∫øt qu·∫£ trong khung gi·ªù
 */
function getPeriodResults(hourlyResults, period) {
    let results = [];
    let periodHours = [];
    
    // X√°c ƒë·ªãnh c√°c gi·ªù trong khung gi·ªù
    switch (period) {
        case 'morning':
            periodHours = [5, 6, 7, 8, 9, 10];
            break;
        case 'noon':
            periodHours = [11, 12];
            break;
        case 'afternoon':
            periodHours = [13, 14, 15, 16, 17];
            break;
        case 'evening':
            periodHours = [18, 19, 20, 21];
            break;
        case 'latenight':
            periodHours = [22, 23, 0, 1, 2, 3, 4];
            break;
    }
    
    // G·ªôp t·∫•t c·∫£ k·∫øt qu·∫£ trong khung gi·ªù
    periodHours.forEach(hour => {
        if (hourlyResults[hour]) {
            results = results.concat(hourlyResults[hour]);
        }
    });
    
    return results;
}

/**
 * V6.0.0: Thu·∫≠t to√°n k·∫øt h·ª£p n√¢ng cao cho x·ªï s·ªë 45 gi√¢y
 * D·ª±a tr√™n ph√¢n t√≠ch t·ª´ 90 chu k·ª≥ th·ª±c t·∫ø v·ªõi t·ªëi ∆∞u cho t·ªëc ƒë·ªô ph·∫£n ·ª©ng nhanh
 * @param {Array} history - M·∫£ng l·ªãch s·ª≠ k·∫øt qu·∫£
 * @param {Number} index - V·ªã tr√≠ trong m·∫£ng numbers c·∫ßn d·ª± ƒëo√°n
 * @returns {Object} K·∫øt qu·∫£ d·ª± ƒëo√°n
 */
function advancedCombinationPattern(history, index) {
    if (!history || history.length < 5) return { confidence: 0 };
    
    // K√≠ch th∆∞·ªõc l·ªãch s·ª≠ ph√π h·ª£p v·ªõi x·ªï s·ªë 45 gi√¢y
    const historyLimit = Math.min(10, history.length); // Gi·∫£m t·ª´ 15 xu·ªëng 10 cho chu k·ª≥ ng·∫Øn
    
    // L·∫•y m·∫´u T/X g·∫ßn ƒë√¢y nh·∫•t
    const pattern = history.slice(0, historyLimit).map(h => h.numbers[index] >= 5 ? 'T' : 'X');
    const recentPattern = pattern.slice(0, 5).join('');
    
    // ƒê·∫øm bi·∫øn th·ªÉ
    let taiCount = 0;
    let xiuCount = 0;
    let alternatingCount = 0;
    let streakLength = 1;
    let maxStreakLength = 1;
    let streakType = pattern[0];
    
    // Ph√¢n t√≠ch chi ti·∫øt
    for (let i = 0; i < pattern.length; i++) {
        // ƒê·∫øm T√†i/X·ªâu
        if (pattern[i] === 'T') taiCount++;
        else xiuCount++;
        
        // ƒê·∫øm s·ªë l·∫ßn ƒë·∫£o chi·ªÅu
        if (i > 0 && pattern[i] !== pattern[i-1]) {
            alternatingCount++;
            // Reset ƒë·∫øm streak khi ƒë·∫£o chi·ªÅu
            streakLength = 1;
        } else {
            // TƒÉng streak khi c√πng lo·∫°i
            streakLength++;
            if (streakLength > maxStreakLength) {
                maxStreakLength = streakLength;
                streakType = pattern[i];
            }
        }
    }
    
    // T√≠nh t·ª∑ l·ªá & ƒë·ªô tin c·∫≠y
    const totalCount = taiCount + xiuCount;
    const taiRate = taiCount / totalCount;
    const alternatingRate = alternatingCount / (totalCount - 1);
    
    // Ph√¢n t√≠ch m·∫´u c·ª• th·ªÉ cho x·ªï s·ªë 45 gi√¢y (d·ª±a tr√™n ph√¢n t√≠ch 90 chu k·ª≥)
    
    // M·∫™U 1: Chu·ªói 3+ c√πng lo·∫°i -> ƒë·∫£o chi·ªÅu (t·ª∑ l·ªá th√†nh c√¥ng cao ~65-70%)
    if (pattern[0] === pattern[1] && pattern[1] === pattern[2]) {
        const consecutive = pattern[0];
        let count = 3;
        
        // ƒê·∫øm ch√≠nh x√°c s·ªë l∆∞·ª£ng li√™n ti·∫øp
        while (count < pattern.length && pattern[count] === consecutive) {
            count++;
        }
        
        // ƒê·ªô tin c·∫≠y tƒÉng theo ƒë·ªô d√†i chu·ªói
        const confidenceBase = 0.8;
        const confidenceBonus = Math.min((count - 3) * 0.03, 0.09);
        
        return {
            confidence: confidenceBase + confidenceBonus,
            predictTai: consecutive === 'X', // ƒê·∫£o chi·ªÅu
            reason: `Ph√°t hi·ªán ${count} ${consecutive} li√™n ti·∫øp, d·ª± ƒëo√°n ƒë·∫£o chi·ªÅu`
        };
    }
    
    // M·∫™U 2: D·∫°ng k·∫πp gi·ªØa (T-X-T ho·∫∑c X-T-X) trong 3 k·ª≥ g·∫ßn nh·∫•t
    if (pattern[0] === pattern[2] && pattern[0] !== pattern[1]) {
        return {
            confidence: 0.82,
            predictTai: pattern[0] === 'T',
            reason: `Ph√°t hi·ªán m·∫´u k·∫πp ${pattern[0]}-${pattern[1]}-${pattern[0]}, d·ª± ƒëo√°n ti·∫øp t·ª•c ${pattern[0]}`
        };
    }
    
    // M·∫™U 3: M·∫´u xen k·∫Ω ho√†n h·∫£o (TXTXT ho·∫∑c XTXTX)
    const isAlternating = alternatingRate >= 0.8;
    if (isAlternating && pattern.length >= 5) {
        // Ki·ªÉm tra 5 k·ª≥ g·∫ßn ƒë√¢y c√≥ ho√†n to√†n xen k·∫Ω kh√¥ng
        let perfectAlt = true;
        for (let i = 0; i < 4; i++) {
            if (pattern[i] === pattern[i+1]) {
                perfectAlt = false;
                break;
            }
        }
        
        if (perfectAlt) {
            return {
                confidence: 0.85,
                predictTai: pattern[0] === 'X',
                reason: `Ph√°t hi·ªán m·∫´u xen k·∫Ω ho√†n h·∫£o ${recentPattern}, d·ª± ƒëo√°n ti·∫øp t·ª•c m·∫´u`
            };
        }
    }
    
    // M·∫™U 4: Ph√°t hi·ªán c√°c tr√¨nh t·ª± ƒë·∫∑c bi·ªát trong 4 k·ª≥ g·∫ßn nh·∫•t
    const last4 = pattern.slice(0, 4).join('');
    
    if (last4 === 'TXXT') {
        return {
            confidence: 0.84,
            predictTai: false,
            reason: `Ph√°t hi·ªán m·∫´u TXXT, d·ª± ƒëo√°n ti·∫øp theo l√† X (x√°c su·∫•t cao)`
        };
    } else if (last4 === 'XTTX') {
        return {
            confidence: 0.84,
            predictTai: true,
            reason: `Ph√°t hi·ªán m·∫´u XTTX, d·ª± ƒëo√°n ti·∫øp theo l√† T (x√°c su·∫•t cao)`
        };
    }
    
    // M·∫™U 5: Xu h∆∞·ªõng r√µ r√†ng (>70% c√πng m·ªôt lo·∫°i)
    if (taiRate >= 0.7) {
        return {
            confidence: 0.75,
            predictTai: true,
            reason: `Xu h∆∞·ªõng T√†i m·∫°nh (${Math.round(taiRate * 100)}%), d·ª± ƒëo√°n duy tr√¨ xu h∆∞·ªõng`
        };
    } else if (taiRate <= 0.3) {
        return {
            confidence: 0.75,
            predictTai: false,
            reason: `Xu h∆∞·ªõng X·ªâu m·∫°nh (${Math.round((1-taiRate) * 100)}%), d·ª± ƒëo√°n duy tr√¨ xu h∆∞·ªõng`
        };
    }
    
    // M·∫™U 6: M·∫´u TTX ho·∫∑c XXT (3 k·ª≥ g·∫ßn nh·∫•t)
    if (pattern[0] === 'X' && pattern[1] === pattern[2] && pattern[1] !== 'X') {
        return {
            confidence: 0.78,
            predictTai: false,
            reason: `Ph√°t hi·ªán m·∫´u X-T-T, d·ª± ƒëo√°n ti·∫øp theo X`
        };
    } else if (pattern[0] === 'T' && pattern[1] === pattern[2] && pattern[1] !== 'T') {
        return {
            confidence: 0.78,
            predictTai: true,
            reason: `Ph√°t hi·ªán m·∫´u T-X-X, d·ª± ƒëo√°n ti·∫øp theo T`
        };
    }
    
    // M·∫™U 7: Hai k·ª≥ g·∫ßn nh·∫•t c√πng lo·∫°i
    if (pattern[0] === pattern[1]) {
        return {
            confidence: 0.73,
            predictTai: pattern[0] !== 'T',
            reason: `2 k·ª≥ ${pattern[0]} li√™n ti·∫øp, d·ª± ƒëo√°n ƒë·∫£o chi·ªÅu`
        };
    }
    
    // M·∫´u m·∫∑c ƒë·ªãnh khi kh√¥ng t√¨m th·∫•y m·∫´u r√µ r√†ng
    return {
        confidence: 0.65,
        predictTai: Math.random() > 0.5, // Random khi kh√¥ng c√≥ m·∫´u r√µ r√†ng
        reason: `Kh√¥ng t√¨m th·∫•y m·∫´u r√µ r√†ng, d·ª± ƒëo√°n ng·∫´u nhi√™n`
    };
}

/**
 * V5.0: √Åp d·ª•ng Kelly Criterion cho qu·∫£n l√Ω v·ªën
 * @param {Number} balance - S·ªë d∆∞ t√†i kho·∫£n
 * @param {Number} odds - T·ª∑ l·ªá th·∫Øng (th∆∞·ªùng l√† 1.95 cho T√†i X·ªâu)
 * @param {Number} probability - X√°c su·∫•t th·∫Øng (0-1)
 * @param {Number} fraction - Ph·∫ßn trƒÉm Kelly s·ª≠ d·ª•ng (0-1)
 * @param {Number} maxRisk - R·ªßi ro t·ªëi ƒëa cho ph√©p (0-1)
 * @returns {Number} S·ªë ti·ªÅn ƒë·∫∑t c∆∞·ª£c ƒë∆∞·ª£c ƒë·ªÅ xu·∫•t
 */
function calculateKellyCriterion(balance, odds = 1.95, probability, fraction = 0.3, maxRisk = 0.05) {
    // T√≠nh to√°n Kelly ƒë·∫ßy ƒë·ªß
    const fullKelly = ((odds * probability) - 1) / (odds - 1);
    
    // Gi·ªõi h·∫°n theo ph·∫ßn trƒÉm Kelly v√† r·ªßi ro t·ªëi ƒëa
    const cappedKelly = Math.min(fullKelly * fraction, maxRisk);
    
    // ƒê·∫£m b·∫£o kh√¥ng √¢m
    const safeKelly = Math.max(cappedKelly, 0);
    
    // T√≠nh s·ªë ti·ªÅn c∆∞·ª£c
    let betAmount = Math.floor(balance * safeKelly);
    
    // L√†m tr√≤n v·ªÅ b·ªôi s·ªë c·ªßa 10,000 ƒë·ªÉ d·ªÖ ƒë·ªçc
    betAmount = Math.ceil(betAmount / 10000) * 10000;
    
    // ƒê·∫£m b·∫£o m·ª©c c∆∞·ª£c t·ªëi thi·ªÉu
    return Math.max(betAmount, 100000);
}

/**
 * ƒê·∫øm s·ªë l·∫ßn thua li√™n ti·∫øp g·∫ßn ƒë√¢y t·ª´ file log
 * @param {string} logFile - ƒê∆∞·ªùng d·∫´n ƒë·∫øn file log
 * @returns {number} S·ªë l·∫ßn thua li√™n ti·∫øp
 */
function calculateRecentLosses(logFile) {
    try {
        if (!fs.existsSync(logFile)) return 0;
        
        const data = fs.readFileSync(logFile, 'utf8');
        const lines = data.split('\n').filter(line => line.trim() !== '');
        
        let consecutiveLosses = 0;
        
        // ƒê·ªçc t·ª´ d√≤ng m·ªõi nh·∫•t (tr√™n c√πng) xu·ªëng
        for (const line of lines) {
            if (line.includes('| Sai |')) {
                consecutiveLosses++;
            } else if (line.includes('| ƒê√∫ng |')) {
                break; // D·ª´ng khi g·∫∑p k·∫øt qu·∫£ ƒë√∫ng
            }
        }
        
        return consecutiveLosses;
    } catch (error) {
        console.error(`L·ªói khi ƒë·ªçc log: ${error.message}`);
        return 0;
    }
}

/**
 * Ph√°t hi·ªán m·∫´u th√≠ch ·ª©ng t·ª´ l·ªãch s·ª≠ v√† tƒÉng c∆∞·ªùng nh·∫≠n di·ªán chu·ªói ƒë·∫∑c bi·ªát
 * @param {Array} history - M·∫£ng l·ªãch s·ª≠ k·∫øt qu·∫£
 * @param {Number} index - V·ªã tr√≠ c·∫ßn d·ª± ƒëo√°n
 * @returns {Object} K·∫øt qu·∫£ d·ª± ƒëo√°n
 */
function detectAdaptivePattern(history, index = 0) {
    // Ki·ªÉm tra ƒë·∫ßu v√†o
    if (!history || !Array.isArray(history) || history.length < 10) {
        return { predictTai: null, confidence: 0, reason: "Kh√¥ng ƒë·ªß d·ªØ li·ªáu" };
    }
    
    let result = { 
        predictTai: null, 
        confidence: 0, 
        reason: "", 
        method: "AdaptivePatternRecognition" 
    };
    
    try {
        // L·∫•y 20 k·∫øt qu·∫£ g·∫ßn nh·∫•t ƒë·ªÉ ph√¢n t√≠ch
        const recentHistory = history.slice(0, Math.min(20, history.length));
        
        // Chuy·ªÉn ƒë·ªïi l·ªãch s·ª≠ th√†nh chu·ªói T√†i/X·ªâu ƒë·ªÉ nh·∫≠n d·∫°ng m·∫´u
        const taiXiuPattern = recentHistory.map(item => {
            const num = item.numbers[index];
            return num >= 5 ? 'T' : 'X';
        }).join('');
        
        // Ph√°t hi·ªán m·∫´u chu·ªói thua ƒë·∫∑c bi·ªát t·ª´ d·ªØ li·ªáu
        // ƒê·ªçc log g·∫ßn nh·∫•t ƒë·ªÉ xem c√≥ chu·ªói thua kh√¥ng
        const dataDir = path.join(__dirname, '..', 'data');
        const logFile = path.join(dataDir, 'prediction_log.txt');
        const recentLosses = calculateRecentLosses(logFile);
        
        // Ki·ªÉm tra xem c√≥ chu·ªói thua li√™n ti·∫øp kh√¥ng
        if (recentLosses >= 2) {
            // Ph√¢n t√≠ch 5 k·∫øt qu·∫£ g·∫ßn nh·∫•t ƒë·ªÉ t√¨m m·∫´u
            const pattern5 = taiXiuPattern.substring(0, 5);
            // Ki·ªÉm tra c√°c m·∫´u ƒë·∫∑c bi·ªát trong chu·ªói thua
            
            // M·∫´u 1: N·∫øu c√≥ 3+ T√†i li√™n ti·∫øp, d·ª± ƒëo√°n X·ªâu ti·∫øp theo
            if (pattern5.startsWith('TTT')) {
                result.predictTai = false;
                result.confidence = 0.82;
                result.reason = "M·∫´u 3+ T√†i li√™n ti·∫øp sau chu·ªói thua";
                result.method = "AdaptiveStreakBreaker";
                return result;
            }
            
            // M·∫´u 2: N·∫øu c√≥ 3+ X·ªâu li√™n ti·∫øp, d·ª± ƒëo√°n T√†i ti·∫øp theo
            if (pattern5.startsWith('XXX')) {
                result.predictTai = true;
                result.confidence = 0.82;
                result.reason = "M·∫´u 3+ X·ªâu li√™n ti·∫øp sau chu·ªói thua";
                result.method = "AdaptiveStreakBreaker";
                return result;
            }
            
            // M·∫´u 3: M·∫´u xen k·∫Ω TXTX, d·ª± ƒëo√°n T ti·∫øp theo
            if (pattern5.startsWith('TXTX')) {
                result.predictTai = true;
                result.confidence = 0.80;
                result.reason = "M·∫´u xen k·∫Ω TXTX sau chu·ªói thua";
                result.method = "AdaptiveStreakBreaker";
                return result;
            }
            
            // M·∫´u 4: M·∫´u xen k·∫Ω XTXT, d·ª± ƒëo√°n X ti·∫øp theo
            if (pattern5.startsWith('XTXT')) {
                result.predictTai = false;
                result.confidence = 0.80;
                result.reason = "M·∫´u xen k·∫Ω XTXT sau chu·ªói thua";
                result.method = "AdaptiveStreakBreaker";
                return result;
            }
        }
        
        // Ti·∫øp t·ª•c v·ªõi logic ph√°t hi·ªán m·∫´u th√¥ng th∆∞·ªùng
        // ... (gi·ªØ nguy√™n code hi·ªán t·∫°i)
    } catch (error) {
        console.error(`‚ùå L·ªói khi ph√¢n t√≠ch m·∫´u th√≠ch ·ª©ng: ${error.message}`);
        return { predictTai: null, confidence: 0, reason: "L·ªói khi ph√¢n t√≠ch m·∫´u th√≠ch ·ª©ng" };
    }
    
    return result;
}

module.exports = {
    detectCyclicalReversals,
    detectShortAlternatingPattern,
    detectLongStreaks,
    detectFastPattern,
    balancedAnalysis,
    generateNumbers,
    analyzeLimitPerformance,
    detectTimeBasedPattern,
    getTimePeriod,
    getPeriodResults,
    advancedCombinationPattern,
    calculateKellyCriterion,
    detectAdaptivePattern
};